# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: MIT

AWSTemplateFormatVersion: '2010-09-09'

Description: Demo of an AWS Fargate cluster hosting APIs exposed through API Gateway.

Parameters:
  EnvironmentName:
    Type: String
    Default: ecsapi-demo
    Description: "A friendly environment name that will be used for namespacing all cluster resources. Example: staging, qa, or production"
  PrivateDNSNamespaceName:
    Type: String
    Default: service
    Description: "The private DNS name that identifies the name that you want to use to locate your resources"
  MinContainersSolarSystem:
    Type: Number
    Default: 3
    Description: "Minimum number of ECS tasks per ECS service"
  MaxContainersSolarSystem:
    Type: Number
    Default: 30
    Description: "Maximum number of ECS tasks per ECS service"
  AutoScalingTargetValueSolarSystem:
    Type: Number
    Default: 50
    Description: "Target CPU utilization (%) for ECS services auto scaling"
  MinContainersPetstorePets:
    Type: Number
    Default: 3
    Description: "Minimum number of ECS tasks per ECS service"
  MaxContainersPetstorePets:
    Type: Number
    Default: 30
    Description: "Maximum number of ECS tasks per ECS service"
  AutoScalingTargetValuePetstorePets:
    Type: Number
    Default: 50
    Description: "Target CPU utilization (%) for ECS services auto scaling"
  ServiceName:
    Type: String
    Default: apig-demo-app
    Description: A name for the service
  ImageUrl:
    Type: String
    Default: ""
    Description: The url of a docker image that contains the application process that
      will handle the traffic for this service
  RESTAPIServiceName:
    Type: String
    Default: solar-system-backend
    Description: A name for the service
  RESTAPIImageUrl:
    Type: String
    Default: ""
    Description: The url of a docker image that contains the application process that
      will handle the traffic for this service
  SolarSystemBackendImageUrl:
    Type: String
    Default: ''
  ContainerPort:
    Type: Number
    Default: 8080
    Description: What port number the application inside the docker container is binding to
  ContainerCpu:
    Type: Number
    Default: 256
    Description: How much CPU to give the container. 1024 is 1 CPU
  ContainerMemory:
    Type: Number
    Default: 512
    Description: How much memory in megabytes to give the container
  Path:
    Type: String
    Default: "*"
    Description: A path on the load balancer that this service
      should be connected to. Use * to send all load balancer
      traffic to this service.
  Priority:
    Type: Number
    Default: 1
    Description: The priority for the routing rule added to the load balancer.
      This only applies if your have multiple services which have been
      assigned to different paths on the load balancer.
  DesiredCount:
    Type: Number
    Default: 2
    Description: How many copies of the service task to run
  OktaIssuer:
    Type: String
    Default: ''
  OktaAudience:
    Type: String
    Default: 'api://default'
  AuthorizerName:
    Type: String
    Default: 'authorizer-auth-function'
  FrontendHost:
    Type: String
    Default: ''

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      -
        Label:
          default: "Generic"
        Parameters:
          - EnvironmentName
          - PrivateDNSNamespaceName
      -
        Label:
          default: "SolarSystem Service"
        Parameters:
          - MinContainersSolarSystem
          - MaxContainersSolarSystem
          - AutoScalingTargetValueSolarSystem
      -
        Label:
          default: "PetstorePets Service"
        Parameters:
          - MinContainersPetstorePets
          - MaxContainersPetstorePets
          - AutoScalingTargetValuePetstorePets

Mappings:
  SubnetConfig:
    VPC:
      CIDR: '10.0.0.0/16'
    PublicOne:
      CIDR: '10.0.0.0/24'
    PublicTwo:
      CIDR: '10.0.1.0/24'
    PublicThree:
      CIDR: '10.0.2.0/24'
    PrivateOne:
      CIDR: '10.0.100.0/24'
    PrivateTwo:
      CIDR: '10.0.101.0/24'
    PrivateThree:
      CIDR: '10.0.102.0/24'

Resources:

  DynamoDBTablePetstorePets:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: petId
          AttributeType: S
      KeySchema:
        - AttributeName: petId
          KeyType: HASH

  VPC:
    Type: AWS::EC2::VPC
    Properties:
      EnableDnsSupport: true
      EnableDnsHostnames: true
      CidrBlock: !FindInMap ['SubnetConfig', 'VPC', 'CIDR']

  PublicSubnetOne:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select
        - 0
        - Fn::GetAZs: !Ref 'AWS::Region'
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'PublicOne', 'CIDR']
      MapPublicIpOnLaunch: true
  PublicSubnetTwo:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select
        - 1
        - Fn::GetAZs: !Ref 'AWS::Region'
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'PublicTwo', 'CIDR']
      MapPublicIpOnLaunch: true
  PublicSubnetThree:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select
        - 2
        - Fn::GetAZs: !Ref 'AWS::Region'
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'PublicThree', 'CIDR']
      MapPublicIpOnLaunch: true

  PrivateSubnetOne:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select
        - 0
        - Fn::GetAZs: !Ref 'AWS::Region'
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'PrivateOne', 'CIDR']
  PrivateSubnetTwo:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select
        - 1
        - Fn::GetAZs: !Ref 'AWS::Region'
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'PrivateTwo', 'CIDR']
  PrivateSubnetThree:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select
        - 2
        - Fn::GetAZs: !Ref 'AWS::Region'
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'PrivateThree', 'CIDR']

  InternetGateway:
    Type: AWS::EC2::InternetGateway
  GatewayAttachement:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref 'VPC'
      InternetGatewayId: !Ref 'InternetGateway'
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: GatewayAttachement
    Properties:
      RouteTableId: !Ref 'PublicRouteTable'
      DestinationCidrBlock: '0.0.0.0/0'
      GatewayId: !Ref 'InternetGateway'
  PublicSubnetOneRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetOne
      RouteTableId: !Ref PublicRouteTable
  PublicSubnetTwoRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetTwo
      RouteTableId: !Ref PublicRouteTable
  PublicSubnetThreeRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetThree
      RouteTableId: !Ref PublicRouteTable

  NatGatewayOneAttachment:
    Type: AWS::EC2::EIP
    DependsOn: GatewayAttachement
    Properties:
      Domain: vpc
  NatGatewayTwoAttachment:
    Type: AWS::EC2::EIP
    DependsOn: GatewayAttachement
    Properties:
      Domain: vpc
  NatGatewayThreeAttachment:
    Type: AWS::EC2::EIP
    DependsOn: GatewayAttachement
    Properties:
      Domain: vpc
  NatGatewayOne:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGatewayOneAttachment.AllocationId
      SubnetId: !Ref PublicSubnetOne
  NatGatewayTwo:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGatewayTwoAttachment.AllocationId
      SubnetId: !Ref PublicSubnetTwo
  NatGatewayThree:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGatewayThreeAttachment.AllocationId
      SubnetId: !Ref PublicSubnetThree
  PrivateRouteTableOne:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
  PrivateRouteOne:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTableOne
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGatewayOne
  PrivateRouteTableOneAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTableOne
      SubnetId: !Ref PrivateSubnetOne
  PrivateRouteTableTwo:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
  PrivateRouteTwo:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTableTwo
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGatewayTwo
  PrivateRouteTableTwoAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTableTwo
      SubnetId: !Ref PrivateSubnetTwo
  PrivateRouteTableThree:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
  PrivateRouteThree:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTableThree
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGatewayThree
  PrivateRouteTableThreeAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTableThree
      SubnetId: !Ref PrivateSubnetThree

  DynamoDBEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: "*"
            Principal: "*"
            Resource: "*"
      RouteTableIds:
        - !Ref 'PrivateRouteTableOne'
        - !Ref 'PrivateRouteTableTwo'
        - !Ref 'PrivateRouteTableThree'
      ServiceName: !Sub com.amazonaws.${AWS::Region}.dynamodb
      VpcId: !Ref 'VPC'

  ECSCluster:
    Type: AWS::ECS::Cluster

  ContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the Fargate containers
      VpcId: !Ref 'VPC'

  ContainerSecurityGroupSelfIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref ContainerSecurityGroup
      SourceSecurityGroupId: !Ref ContainerSecurityGroup
      IpProtocol: tcp
      FromPort: 8080
      ToPort: 8080

  EcsSecurityGroupIngressFromPublicALB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the public ALB
      GroupId: !Ref ContainerSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId: !Ref 'PublicLoadBalancerSG'

  # Public load balancer, hosted in public subnets that is accessible
  # to the public, and is intended to route traffic to one or more public
  # facing services. This is used for accepting traffic from the public
  # internet and directing it to public facing microservices
  PublicLoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the public facing load balancer
      VpcId: !Ref VPC
      SecurityGroupIngress:
        # Allow access to ALB from anywhere on the internet
        - CidrIp: 0.0.0.0/0
          IpProtocol: "-1"

  PublicLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '30'
      Subnets:
        # The load balancer is placed into the public subnets, so that traffic
        # from the internet can reach the load balancer directly via the internet gateway
        - !Ref PublicSubnetOne
        - !Ref PublicSubnetTwo
      SecurityGroups: [ !Ref 'PublicLoadBalancerSG' ]

  PublicLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref TargetGroup
          Type: 'forward'
      LoadBalancerArn: !Ref 'PublicLoadBalancer'
      Port: 80
      Protocol: HTTP

  AutoScalingRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceAutoscaleRole'

  ECSRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: ecs-service
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'ec2:AttachNetworkInterface'
                  - 'ec2:CreateNetworkInterface'
                  - 'ec2:CreateNetworkInterfacePermission'
                  - 'ec2:DeleteNetworkInterface'
                  - 'ec2:DeleteNetworkInterfacePermission'
                  - 'ec2:Describe*'
                  - 'ec2:DetachNetworkInterface'

                  - 'elasticloadbalancing:DeregisterInstancesFromLoadBalancer'
                  - 'elasticloadbalancing:DeregisterTargets'
                  - 'elasticloadbalancing:Describe*'
                  - 'elasticloadbalancing:RegisterInstancesWithLoadBalancer'
                  - 'elasticloadbalancing:RegisterTargets'
                Resource: '*'

  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs-tasks.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: AmazonECSTaskExecutionRolePolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  # Allow the ECS Tasks to download images from ECR
                  - 'ecr:GetAuthorizationToken'
                  - 'ecr:BatchCheckLayerAvailability'
                  - 'ecr:GetDownloadUrlForLayer'
                  - 'ecr:BatchGetImage'

                  # Allow the ECS tasks to upload logs to CloudWatch
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: '*'

  PrivateDNSNamespace:
    Type: 'AWS::ServiceDiscovery::PrivateDnsNamespace'
    Properties:
      Vpc: !Ref VPC
      Name: !Ref PrivateDNSNamespaceName

  ServiceDiscoveryServiceSolarSystem:
    Type: 'AWS::ServiceDiscovery::Service'
    Properties:
      DnsConfig:
        DnsRecords:
          - Type: SRV
            TTL: 60
        NamespaceId: !Ref PrivateDNSNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: 'solarsystem'

  ServiceDiscoveryServicePetstorePets:
    Type: 'AWS::ServiceDiscovery::Service'
    Properties:
      DnsConfig:
        DnsRecords:
          - Type: SRV
            TTL: 60
        NamespaceId: !Ref PrivateDNSNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: 'pets.petstore'

  TaskRolePetstorePets:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: dynamodb-table-access
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:BatchGet*
                  - dynamodb:DescribeStream
                  - dynamodb:DescribeTable
                  - dynamodb:Get*
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:BatchWrite*
                  - dynamodb:CreateTable
                  - dynamodb:Delete*
                  - dynamodb:Update*
                  - dynamodb:PutItem
                Resource: !GetAtt DynamoDBTablePetstorePets.Arn

  TaskRoleFrontend:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ecs-tasks.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

  TaskRoleSolarSystem:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ecs-tasks.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

  TaskDefinitionSolarSystem:
    Type: 'AWS::ECS::TaskDefinition'
    Properties:
      TaskRoleArn: !GetAtt TaskRoleSolarSystem.Arn
      ExecutionRoleArn: !GetAtt  TaskRoleSolarSystem.Arn
      RequiresCompatibilities:
        - FARGATE
      ContainerDefinitions:
        - Name: 'solar-system-backend'
          Image: !Sub ${SolarSystemBackendImageUrl}
          Essential: true
          PortMappings:
            - ContainerPort: 8080
              Protocol: tcp
      NetworkMode: awsvpc
      Memory: '512'
      Cpu: '256'

  TaskDefinitionPetstorePets:
    Type: 'AWS::ECS::TaskDefinition'
    Properties:
      TaskRoleArn: !GetAtt TaskRolePetstorePets.Arn
      RequiresCompatibilities:
        - FARGATE
      ContainerDefinitions:
        - Name: 'PetstorePets'
          Image: 'simonepomata/ecsapi-demo-petstore:latest'
          Essential: true
          PortMappings:
            - ContainerPort: 8080
              Protocol: tcp
          Environment:
            - Name: DynamoDBTable
              Value: !Ref DynamoDBTablePetstorePets
      NetworkMode: awsvpc
      Memory: '512'
      Cpu: '256'

  ServiceSolarSystem:
    Type: AWS::ECS::Service
    DependsOn:
      - PrivateRouteOne
      - PrivateRouteTwo
      - PrivateRouteThree
    Properties:
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinitionSolarSystem
      LaunchType: FARGATE
      DesiredCount: 3
      ServiceRegistries:
        - RegistryArn: !GetAtt ServiceDiscoveryServiceSolarSystem.Arn
          Port: 8080
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref PrivateSubnetOne
            - !Ref PrivateSubnetTwo
            - !Ref PrivateSubnetThree
          SecurityGroups:
            - !Ref ContainerSecurityGroup

  ServicePetstorePets:
    Type: AWS::ECS::Service
    DependsOn:
      - PrivateRouteOne
      - PrivateRouteTwo
      - PrivateRouteThree
    Properties:
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinitionPetstorePets
      LaunchType: FARGATE
      DesiredCount: 3
      ServiceRegistries:
        - RegistryArn: !GetAtt ServiceDiscoveryServicePetstorePets.Arn
          Port: 8080
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref PrivateSubnetOne
            - !Ref PrivateSubnetTwo
            - !Ref PrivateSubnetThree
          SecurityGroups:
            - !Ref ContainerSecurityGroup

  AutoScalingTargetSolarSystem:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: !Ref MinContainersSolarSystem
      MaxCapacity: !Ref MaxContainersSolarSystem
      ResourceId: !Join ['/', [service, !Ref ECSCluster, !GetAtt ServiceSolarSystem.Name]]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      RoleARN: !GetAtt AutoScalingRole.Arn

  AutoScalingTargetPetstorePets:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: !Ref MinContainersPetstorePets
      MaxCapacity: !Ref MaxContainersPetstorePets
      ResourceId: !Join ['/', [service, !Ref ECSCluster, !GetAtt ServicePetstorePets.Name]]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      RoleARN: !GetAtt AutoScalingRole.Arn

  AutoScalingPolicySolarSystem:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: !Join ['', [!GetAtt ServiceSolarSystem.Name, '-AutoScalingPolicy']]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref AutoScalingTargetSolarSystem
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        TargetValue: !Ref AutoScalingTargetValueSolarSystem

  AutoScalingPolicyPetstorePets:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: !Join ['', [!GetAtt ServicePetstorePets.Name, '-AutoScalingPolicy']]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref AutoScalingTargetPetstorePets
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        TargetValue: !Ref AutoScalingTargetValuePetstorePets

# REST API resources start:
  RESTApiVPCLink:
    Type: AWS::ApiGateway::VpcLink
    Properties:
      Name: !Sub ${EnvironmentName}-vpc-link
      TargetArns:
        - !Ref RESTApiNetworkLoadBalancer

  RESTApiNetworkLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Type: network
      Subnets:
        - !Ref PrivateSubnetOne
        - !Ref PrivateSubnetTwo
        - !Ref PrivateSubnetThree

  RESTAPITargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 10
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthyThresholdCount: 2
      TargetType: ip
      Name: "RESTAPITargetGroup"
      Port: !Ref 'ContainerPort'
      Protocol: TCP
      UnhealthyThresholdCount: 2
      VpcId: !Ref VPC

  RESTAPILoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref RESTAPITargetGroup
          Type: forward
      LoadBalancerArn: !Ref RESTApiNetworkLoadBalancer
      Port: !Ref ContainerPort
      Protocol: TCP

  # A log group for storing the stdout logs from this service's containers
  RESTAPILogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub ${EnvironmentName}-service-${RESTAPIServiceName}

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  RESTAPITaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Ref 'RESTAPIServiceName'
      Cpu: !Ref 'ContainerCpu'
      Memory: !Ref 'ContainerMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      TaskRoleArn: !GetAtt TaskRoleFrontend.Arn
      ContainerDefinitions:
        - Name: !Ref 'RESTAPIServiceName'
          Cpu: !Ref 'ContainerCpu'
          Memory: !Ref 'ContainerMemory'
          Image: !Ref 'RESTAPIImageUrl'
          PortMappings:
            - ContainerPort: !Ref 'ContainerPort'
          LogConfiguration:
            LogDriver: 'awslogs'
            Options:
              awslogs-group: !Sub ${EnvironmentName}-service-${RESTAPIServiceName}
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Ref 'RESTAPIServiceName'

  # The service. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  RESTAPIService:
    Type: AWS::ECS::Service
    Properties:
      ServiceName: !Ref 'RESTAPIServiceName'
      Cluster: !Ref ECSCluster
      LaunchType: FARGATE
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 75
      DesiredCount: !Ref 'DesiredCount'
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref ContainerSecurityGroup
            - !Ref PublicLoadBalancerSG
          Subnets:
            - !Ref PublicSubnetOne
            - !Ref PublicSubnetTwo
      TaskDefinition: !Ref 'RESTAPITaskDefinition'
      LoadBalancers:
        - ContainerName: !Ref 'RESTAPIServiceName'
          ContainerPort: !Ref 'ContainerPort'
          TargetGroupArn: !Ref 'RESTAPITargetGroup'

  HttpApiVPCLink:
    Type: AWS::ApiGatewayV2::VpcLink
    Properties:
      Name: !Ref EnvironmentName
      SecurityGroupIds:
        - !Ref ContainerSecurityGroup
      SubnetIds:
        - !Ref PrivateSubnetOne
        - !Ref PrivateSubnetTwo
        - !Ref PrivateSubnetThree

  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UsernameAttributes:
        - email
      AutoVerifiedAttributes:
        - email

  UserPoolClient:
    Type: "AWS::Cognito::UserPoolClient"
    Properties:
      UserPoolId: !Ref UserPool
      GenerateSecret: false
      SupportedIdentityProviders:
        - COGNITO
      PreventUserExistenceErrors: ENABLED

  RestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: demo_rest_api
      Description: Shows authenticated and non-authenticated apis.
      FailOnWarnings: true

  LambdaInvocationRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - apigateway.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaRole

  OktaLambdaAuthorizer:
    Type: 'AWS::ApiGateway::Authorizer'
    Properties:
      AuthorizerCredentials: !GetAtt
        - LambdaInvocationRole
        - Arn
      AuthorizerResultTtlInSeconds: 300
      AuthorizerUri: !Join
        - ''
        - - 'arn:aws:apigateway:'
          - !Ref 'AWS::Region'
          - ':lambda:path/2015-03-31/functions/'
          - !Sub 'arn:aws:lambda:us-east-1:${AWS::AccountId}:function:${AuthorizerName}'
          - /invocations
      Type: TOKEN
      IdentitySource: method.request.header.Authorization
      Name: DefaultAuthorizer
      RestApiId: !Ref RestApi

  MoonsRestApiResource:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !GetAtt
        - RestApi
        - RootResourceId
      PathPart: moons

  MoonsGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      RestApiId: !Ref RestApi
      ResourceId: !Ref MoonsRestApiResource
      HttpMethod: GET
      Integration:
        IntegrationResponses:
          - StatusCode: '200'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        ConnectionId: !Ref RESTApiVPCLink
        Type: HTTP
        Uri: !Sub "http://${RESTApiNetworkLoadBalancer.DNSName}:8080/moons"
        ConnectionType: "VPC_LINK"
        IntegrationHttpMethod: "ANY"
      MethodResponses:
        - StatusCode: '200'
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  MoonsCORSOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      RestApiId: !Ref RestApi
      ResourceId: !Ref MoonsRestApiResource
      HttpMethod: OPTIONS
      Integration:
        IntegrationResponses:
          - StatusCode: '200'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
        PassthroughBehavior: WHEN_NO_MATCH
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: '200'
          ResponseModels:
            application/json: 'Empty'
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: false
            method.response.header.Access-Control-Allow-Methods: false
            method.response.header.Access-Control-Allow-Origin: false

  PlanetsRestApiResource:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !GetAtt
        - RestApi
        - RootResourceId
      PathPart: planets

  PlanetsGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref OktaLambdaAuthorizer
      RestApiId: !Ref RestApi
      ResourceId: !Ref PlanetsRestApiResource
      HttpMethod: GET
      Integration:
        IntegrationResponses:
          - StatusCode: '200'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        ConnectionId: !Ref RESTApiVPCLink
        Type: HTTP
        Uri: !Sub "http://${RESTApiNetworkLoadBalancer.DNSName}:8080/planets"
        ConnectionType: "VPC_LINK"
        IntegrationHttpMethod: "ANY"
      MethodResponses:
        - StatusCode: '200'
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  PlanetsCORSOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      RestApiId: !Ref RestApi
      ResourceId: !Ref PlanetsRestApiResource
      HttpMethod: OPTIONS
      Integration:
        IntegrationResponses:
          - StatusCode: '200'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
        PassthroughBehavior: WHEN_NO_MATCH
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: '200'
          ResponseModels:
            application/json: 'Empty'
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: false
            method.response.header.Access-Control-Allow-Methods: false
            method.response.header.Access-Control-Allow-Origin: false

  RESTAPIDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - MoonsGetMethod
      - MoonsCORSOptionsMethod
      - PlanetsGetMethod
      - PlanetsCORSOptionsMethod
    Properties:
      Description: "v1 deploy of the moons api"
      RestApiId: !Ref RestApi

  RESTAPIStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      StageName: "v1"
      RestApiId: !Ref RestApi
      DeploymentId: !Ref RESTAPIDeployment
      TracingEnabled: True
      MethodSettings:
        - ResourcePath: /
          HttpMethod: "GET"
          MetricsEnabled: True
          DataTraceEnabled: True

  HttpApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Body:
        openapi: "3.0.1"
        info:
          title: !Ref EnvironmentName
        components:
          securitySchemes:
            okta:
              type: oauth2
              flows: {}
              x-amazon-apigateway-authorizer:
                identitySource: "$request.header.Authorization"
                jwtConfiguration:
                  audience:
                    - !Sub ${OktaAudience}
                  issuer: !Sub '${OktaIssuer}/oauth2/default'
                type: jwt
        paths:
          /asteroids:
            get:
              responses:
                default:
                  description: "Default response for GET /asteroids"
              security:
                - okta: []
              x-amazon-apigateway-integration:
                payloadFormatVersion: "1.0"
                connectionId: !Ref HttpApiVPCLink
                type: "http_proxy"
                httpMethod: "ANY"
                uri: !GetAtt ServiceDiscoveryServiceSolarSystem.Arn
                connectionType: "VPC_LINK"
          /planets:
            get:
              responses:
                default:
                  description: "Default response for GET /planets"
              x-amazon-apigateway-integration:
                payloadFormatVersion: "1.0"
                connectionId: !Ref HttpApiVPCLink
                type: "http_proxy"
                httpMethod: "ANY"
                uri: !GetAtt ServiceDiscoveryServiceSolarSystem.Arn
                connectionType: "VPC_LINK"
        x-amazon-apigateway-cors:
          # This is a Test client web app that invokes the API, used in the blog post, for demonstration purposes only.
          # In production, make sure that you do NOT allow any untrusted origin.
          allowOrigins:
            - !Ref OktaIssuer
            - !Join ['', ['http://', !GetAtt PublicLoadBalancer.DNSName]]
            - !Ref FrontendHost
          allowHeaders:
            - '*'
          allowMethods:
            - 'PUT'
            - 'GET'
        x-amazon-apigateway-importexport-version: "1.0"

  APILogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      RetentionInDays: 7

  HttpApiStage:
    Type: 'AWS::ApiGatewayV2::Stage'
    Properties:
      StageName: '$default'
      ApiId: !Ref 'HttpApi'
      AutoDeploy: true
      AccessLogSettings:
        DestinationArn: !GetAtt APILogGroup.Arn
        Format: '{ "requestId":"$context.requestId", "ip": "$context.identity.sourceIp", "requestTime":"$context.requestTime", "httpMethod":"$context.httpMethod","routeKey":"$context.routeKey", "status":"$context.status","protocol":"$context.protocol", "responseLength":"$context.responseLength" }'

  # A log group for storing the stdout logs from this service's containers
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub ${EnvironmentName}-service-${ServiceName}

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Ref 'ServiceName'
      Cpu: !Ref 'ContainerCpu'
      Memory: !Ref 'ContainerMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      TaskRoleArn: !GetAtt TaskRoleFrontend.Arn
      ContainerDefinitions:
        - Name: !Ref 'ServiceName'
          Cpu: !Ref 'ContainerCpu'
          Memory: !Ref 'ContainerMemory'
          Image: !Ref 'ImageUrl'
          PortMappings:
            - ContainerPort: !Ref 'ContainerPort'
          LogConfiguration:
            LogDriver: 'awslogs'
            Options:
              awslogs-group: !Sub ${EnvironmentName}-service-${ServiceName}
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Ref 'ServiceName'

  # The service. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  Service:
    Type: AWS::ECS::Service
    DependsOn: LoadBalancerRule
    Properties:
      ServiceName: !Ref 'ServiceName'
      Cluster: !Ref ECSCluster
      LaunchType: FARGATE
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 75
      DesiredCount: !Ref 'DesiredCount'
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref ContainerSecurityGroup
          Subnets:
            - !Ref PublicSubnetOne
            - !Ref PublicSubnetTwo
      TaskDefinition: !Ref 'TaskDefinition'
      LoadBalancers:
        - ContainerName: !Ref 'ServiceName'
          ContainerPort: !Ref 'ContainerPort'
          TargetGroupArn: !Ref 'TargetGroup'

  # A target group. This is used for keeping track of all the tasks, and
  # what IP addresses / port numbers they have. You can query it yourself,
  # to use the addresses yourself, but most often this target group is just
  # connected to an application load balancer, or network load balancer, so
  # it can automatically distribute traffic across all the targets.
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      TargetType: ip
      Name: !Ref 'ServiceName'
      Port: !Ref 'ContainerPort'
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !Ref VPC

  # Create a rule on the load balancer for routing traffic to the target group
  LoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref 'TargetGroup'
          Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values: [!Ref 'Path']
      ListenerArn: !Ref PublicLoadBalancerListener
      Priority: !Ref 'Priority'

  # Enable autoscaling for this service
  ScalableTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    DependsOn: Service
    Properties:
      ServiceNamespace: 'ecs'
      ScalableDimension: 'ecs:service:DesiredCount'
      ResourceId:
        Fn::Join:
          - '/'
          - - service
            - !Ref ECSCluster
            - !Ref 'ServiceName'
      MinCapacity: 2
      MaxCapacity: 10
      RoleARN: !GetAtt AutoScalingRole.Arn

  # Create scaling policies for the service
  ScaleDownPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    DependsOn: ScalableTarget
    Properties:
      PolicyName:
        Fn::Join:
          - '/'
          - - scale
            - !Ref 'EnvironmentName'
            - !Ref 'ServiceName'
            - down
      PolicyType: StepScaling
      ResourceId:
        Fn::Join:
          - '/'
          - - service
            - !Ref ECSCluster
            - !Ref 'ServiceName'
      ScalableDimension: 'ecs:service:DesiredCount'
      ServiceNamespace: 'ecs'
      StepScalingPolicyConfiguration:
        AdjustmentType: 'ChangeInCapacity'
        StepAdjustments:
          - MetricIntervalUpperBound: 0
            ScalingAdjustment: -1
        MetricAggregationType: 'Average'
        Cooldown: 60

  ScaleUpPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    DependsOn: ScalableTarget
    Properties:
      PolicyName:
        Fn::Join:
          - '/'
          - - scale
            - !Ref 'EnvironmentName'
            - !Ref 'ServiceName'
            - up
      PolicyType: StepScaling
      ResourceId:
        Fn::Join:
          - '/'
          - - service
            - !Ref ECSCluster
            - !Ref 'ServiceName'
      ScalableDimension: 'ecs:service:DesiredCount'
      ServiceNamespace: 'ecs'
      StepScalingPolicyConfiguration:
        AdjustmentType: 'ChangeInCapacity'
        StepAdjustments:
          - MetricIntervalLowerBound: 0
            MetricIntervalUpperBound: 15
            ScalingAdjustment: 1
          - MetricIntervalLowerBound: 15
            MetricIntervalUpperBound: 25
            ScalingAdjustment: 2
          - MetricIntervalLowerBound: 25
            ScalingAdjustment: 3
        MetricAggregationType: 'Average'
        Cooldown: 60

Outputs:
  HTTPAPIInvokeURL:
    Description: Invoke URL for the HTTP API
    Value: !Sub 'https://${HttpApi}.execute-api.${AWS::Region}.amazonaws.com'
  HTTPAPIInvokeURLAsteroids:
    Description: Invoke URL for the HTTP API for the service asteroids
    Value: !Sub 'https://${HttpApi}.execute-api.${AWS::Region}.amazonaws.com/asteroids/'
  HTTPAPIInvokeURLPlanets:
    Description: Invoke URL for the HTTP API for the service moons
    Value: !Sub 'https://${HttpApi}.execute-api.${AWS::Region}.amazonaws.com/planets/'
  RESTAPIInvokeURLPlanets:
    Description: Invoke URL for the HTTP API for the service planets
    Value: !Sub 'https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/v1/planets/'
  RESTAPIInvokeURLMoons:
    Description: Invoke URL for the HTTP API for the service planets
    Value: !Sub 'https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/v1/moons/'
  RESTAPIId:
    Description: The ID of the REST API
    Value: !Ref RestApi
  APIId:
    Description: The ID of the HTTP API
    Value: !Ref 'HttpApi'
  ECSClusterName:
    Description: The name of the ECS cluster
    Value: !Ref 'ECSCluster'
  VpcId:
    Description: The ID of the VPC that this stack is deployed in
    Value: !Ref 'VPC'
  ContainerSecurityGroup:
    Description: A security group used to allow Fargate containers to receive traffic
    Value: !Ref 'ContainerSecurityGroup'
  PrivateDNSNamespace:
    Description: The ID of the private DNS namespace.
    Value: !Ref 'PrivateDNSNamespace'